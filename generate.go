package main

import (
	"bytes"
	"context"
	"fmt"
	"go/doc"
	"sort"
	"strings"
	"sync"

	stderrors "errors"
	stdpath "path"

	"github.com/diamondburned/gotk4/gir/girgen/strcases"
	"github.com/hashicorp/go-hclog"
	"github.com/pb33f/libopenapi"
	"github.com/pkg/errors"
	"github.com/sourcegraph/conc/pool"
	"golang.org/x/exp/constraints"
	"golang.org/x/exp/slices"
	"gopkg.in/yaml.v3"
	"libdb.so/arikawa-generator/internal/cmt"
	"libdb.so/arikawa-generator/internal/darkfuckingmagic"
	"libdb.so/arikawa-generator/internal/docread"

	openapibase "github.com/pb33f/libopenapi/datamodel/high/base"
)

type generateState struct {
	sync.Mutex
	generated  map[string]struct{}
	errors     []error
	errorCount int

	ctx context.Context
}

func (e *generateState) addError(err error) {
	e.Lock()
	defer e.Unlock()

	e.errorCount++
	if len(e.errors) < 10 {
		e.errors = append(e.errors, err)
	}
}

const primitives = `
// Optional is a type alias for optional values.
//
// # Compatibility Note
//
// In the future, this type will be replaced with an opaque type. This means
// that the type might not be a pointer anymore. Because of this, it is
// recommended to use the methods provided by this package to interact with
// this type.
type Optional[T any] *struct{ v T }

// Some returns an optional value from a non-nil value.
func Some[T any](v T) Optional[T] { return Optional[T]{v} }

// None returns a nil optional value.
func None[T any]() Optional[T] { return nil }

// Unwrap returns the value of the optional, or panics if the optional is nil.
func (o Optional[T]) Unwrap() T {
	if o == nil {
		t := reflect.TypeOf((*T)(nil)).Elem().String()
		panic("attempted to unwrap nil Optional[" + t + "]")
	}
	return o.v
}

// IsNone returns true if the optional is nil.
func (o Optional[T]) IsNone() bool { return o == nil }

// PtrTo returns a pointer to the given value.
func PtrTo[T any](v T) *T { return &v }
`

// Generate generates the code using the given document.
func Generate(doc libopenapi.Document, pkgName string) ([]byte, error) {
	v3doc, errs := doc.BuildV3Model()
	if errs != nil {
		err := stderrors.Join(errs...)
		return nil, errors.Wrap(err, "failed to build OpenAPI v3 model")
	}

	var buf bytes.Buffer
	buf.WriteString("// Code generated by arikawa-generator. DO NOT EDIT.\n\n")
	buf.WriteString("package " + pkgName + "\n\n")
	buf.WriteString(primitives)

	state := &generateState{ctx: context.TODO()}

	// Trim off "Response" if there's no collision.
	for name, schema := range v3doc.Model.Components.Schemas {
		name = strings.TrimSuffix(name, "Response")
		if _, ok := v3doc.Model.Components.Schemas[name]; !ok {
			v3doc.Model.Components.Schemas[name] = schema
		}
	}

	schemaBytes := parallelMapAttrs(v3doc.Model.Components.Schemas,
		func(name string, proxy *openapibase.SchemaProxy) []byte {
			return generateSchema(state, schemaPath{{Name: name, SchemaProxy: proxy}})
		})
	schemaBytesIter := orderedMap(schemaBytes)
	schemaBytesIter(func(name string, generated []byte) bool {
		buf.Write(generated)
		return true
	})

	if state.errorCount > 0 {
		err := stderrors.Join(state.errors...)
		return nil, errors.Wrapf(err, "encountered %d errors such as", state.errorCount)
	}

	return buf.Bytes(), nil
}

type generator struct {
	output *bytes.Buffer
	state  *generateState
}

func generateSchema(state *generateState, path schemaPath) []byte {
	g := &generator{output: new(bytes.Buffer), state: state}
	fmt.Fprintf(g.output, "type %s ", pascalToGo(path.CurrentName()))
	g.error(g.generateSchema(path))
	fmt.Fprintf(g.output, "\n\n")
	return g.output.Bytes()
}

func (g *generator) error(err error) {
	if err != nil {
		g.state.addError(err)
	}
}

func (g *generator) captured(f func(*generator)) string {
	g2 := &generator{output: new(bytes.Buffer), state: g.state}
	f(g2)
	return g2.output.String()
}

const (
	pathSchemas   = "#/components/schemas"
	pathResponses = "#/components/responses"
)

var enumNames = NewSet("type", "flags")

func (g *generator) generateSchema(path schemaPath) error {
	proxy := path.CurrentProxy()
	if proxy.IsReference() {
		switch ref := proxy.GetReference(); stdpath.Dir(ref) {
		case pathSchemas:
			name := stdpath.Base(ref)
			fmt.Fprintf(g.output, "%s", pascalToGo(name))
			return nil
		case pathResponses:
			return nil // TODO
		default:
			return fmt.Errorf("unknown reference %q", ref)
		}
	}

	schema := path.Current()

	ptype, err := extractPrimaryType(schema.Type)
	if err != nil {
		return fmt.Errorf("schema %s has invalid type: %v", path, err)
	}

	if ptype.Nullable {
		fmt.Fprintf(g.output, "*")
	}

	switch ptype.Type {
	case "object":
		var docCandidateFields map[string]docread.FieldInfo
		// if candidates := calculateTopLikelihood(path, schema); len(candidates) > 0 {
		// 	topCandidate := candidates[0]
		// 	docCandidateFields = docread.ToFieldMap(topCandidate.FieldInfos())
		// }

		fmt.Fprintf(g.output, "struct {\n")

		propertyNames := make([]string, 0, len(schema.Properties))
		for name := range schema.Properties {
			propertyNames = append(propertyNames, name)
		}

		// This OpenAPI library is very funny in the sense that everything we
		// can use actually contains line numbers. So we can sort the properties
		// by line number and get deterministic output.
		propertyLines := make(map[string]int, len(propertyNames))
		for _, name := range propertyNames {
			lowProperty := schema.Properties[name].GoLow()
			propKeyNode := darkfuckingmagic.UnexportedField[*yaml.Node](lowProperty, "kn")
			propertyLines[name] = propKeyNode.Line
		}
		sort.Slice(propertyNames, func(i, j int) bool {
			return propertyLines[propertyNames[i]] < propertyLines[propertyNames[j]]
		})

		for _, name := range propertyNames {
			proxy := schema.Properties[name]
			optional := !slices.Contains(schema.Required, name)

			docField, ok := docCandidateFields[name]
			if ok {
				indent := len(path) - 1
				comment := cmt.Prettify(snakeToGo(name), docField.Comment, cmt.Opts{
					OriginalName: name,
				})
				fmt.Fprintf(g.output, "%s", wrapComment(comment, indent))
			}

			fmt.Fprintf(g.output, "\t%s ", snakeToGo(name))
			if optional {
				fmt.Fprintf(g.output, "Optional[")
			}

			t := g.captured(func(g *generator) {
				g.error(g.generateSchema(path.Push(name, proxy)))
			})

			if optional {
				// Remove pointer from type if the type is already optional.
				t = strings.TrimPrefix(t, "*")
			}

			g.output.WriteString(t)

			if optional {
				fmt.Fprintf(g.output, "]")
			}

			jsonKey := name
			if optional {
				jsonKey += ",omitempty"
			}
			fmt.Fprintf(g.output, " `json:%q`", jsonKey)
			fmt.Fprintln(g.output)
		}

		fmt.Fprintf(g.output, "}")
		return nil
	case "array":
		if !schema.Items.IsA() {
			return fmt.Errorf("schema %s has array type but no items", path)
		}
		fmt.Fprintf(g.output, "[]")
		g.error(g.generateSchema(path.Push("[]", schema.Items.A)))
		return nil
	case "string":
		return g.generateString(path)
	case "integer":
		var intType string
		if len(schema.AllOf) == 1 && schema.AllOf[0].IsReference() {
			ref := schema.AllOf[0].GetReference()
			if stdpath.Dir(ref) == pathSchemas {
				intType = pascalToGo(stdpath.Base(ref))
			}
		}
		if intType == "" && enumNames.Has(path.CurrentName()) {
			log := hclog.FromContext(g.state.ctx)
			log.Warn(path.CurrentName()+" is integer but should be enum", "path", path.String())
		}
		if intType == "" && schema.Format != "" {
			intType = schema.Format
		}
		if intType == "" {
			intType = "int"
		}
		fmt.Fprintf(g.output, "%s", intType)
		return nil
	case "number":
		fmt.Fprintf(g.output, "float64")
		return nil
	case "boolean":
		fmt.Fprintf(g.output, "bool")
		return nil
	case "null":
		fmt.Fprintf(g.output, "*struct{}")
		return nil
	}

	// TODO: generate Validate() if !opts.anonymous

	switch {
	// case schema.AllOf != nil:
	// 	return g.generateAllOf(path, schema.AllOf)
	// case schema.AnyOf != nil:
	// 	return g.generateAnyOf(path, schema.AnyOf)
	// case schema.OneOf != nil:
	// 	return g.generateOneOf(path, schema.OneOf)
	case schema.Not != nil:
		return fmt.Errorf("unsupported 'not' schema %s", path)
	}

	fmt.Fprintf(g.output, "struct{ /* %v */ }", schema.Type)
	return nil
}

func (g *generator) generateString(path schemaPath) error {
	schema := path.Current()
	switch schema.Format {
	case "snowflake":
		fmt.Fprintf(g.output, "%s", g.guessSnowflake(path))
	case "date-time":
		fmt.Fprintf(g.output, "time.Time")
	default:
		fmt.Fprintf(g.output, "string")
	}

	return nil
}

func wrapComment(text string, level int) string {
	indentWidth := level*4 + len("// ")
	indentStr := strings.Repeat(" ", indentWidth)
	indentStr += "// "

	var s strings.Builder
	doc.ToText(&s, text, indentStr, "    ", 80-indentWidth)
	return s.String()
}

type primaryType struct {
	Type     string
	Nullable bool
}

func extractPrimaryType(types []string) (primaryType, error) {
	switch len(types) {
	case 0:
		return primaryType{}, nil
	case 1:
		return primaryType{Type: types[0]}, nil
	case 2:
		nullIx := slices.Index(types, "null")
		if nullIx == -1 {
			return primaryType{}, errors.New("schema has more than one type")
		}
		return primaryType{Type: types[1-nullIx], Nullable: true}, nil
	default:
		return primaryType{}, errors.New("schema has more than one type")
	}
}

func (g *generator) guessSnowflake(path schemaPath) string {
	if path.CurrentName() == "[]" {
		// skip
		path = path.Parent()
	}

	kind, ok := snowflakeFields[path.String()]
	if ok {
		return kind + "ID"
	}

	fieldName := snakeToGo(path.CurrentName())
	parentName := pascalToGo(path.Parent().CurrentName())

	for kind := range snowflakes {
		if false ||
			(kind+"ID" == fieldName) ||
			(kind+"IDs" == fieldName) ||
			(strings.HasSuffix(fieldName, kind)) ||
			(strings.HasSuffix(fieldName, kind+"s")) ||
			(strings.HasSuffix(fieldName, kind+"ID")) ||
			(strings.HasSuffix(fieldName, kind+"IDs")) ||
			(fieldName == "ID" && strings.HasPrefix(parentName, kind)) {

			return kind + "ID"
		}
	}

	log := hclog.FromContext(g.state.ctx)
	log.Debug("unknown snowflake field",
		"path", path.String(),
		"field", fieldName,
		"parent", parentName)

	return "Snowflake"
}

func (g *generator) generateAllOf(path schemaPath, proxies []*openapibase.SchemaProxy) error {
	return nil
}

func (g *generator) generateAnyOf(path schemaPath, proxies []*openapibase.SchemaProxy) error {
	return nil
}

func (g *generator) generateOneOf(path schemaPath, proxies []*openapibase.SchemaProxy) error {
	// Special case: Discord gives [{type: null}, T].
	if len(proxies) == 2 {
		resolved, err := resolveSchemas(proxies)
		if err != nil {
			return err
		}

		nullIx := slices.IndexFunc(resolved, func(schema *openapibase.Schema) bool {
			return len(schema.Type) == 1 && schema.Type[0] == "null"
		})
		if nullIx != -1 {
			fmt.Fprintf(g.output, "*")
			g.error(g.generateSchema(path.Push("", proxies[1-nullIx])))
			return nil
		}
	}

	return nil
}

// orderedMap returns a function that iterates over the given map in a
// deterministic order.
//
// Usage:
//
//    for k, v := range orderedMap(m) {
//    	// ...
//    }
//
func orderedMap[K constraints.Ordered, V any](m map[K]V) func(func(K, V) bool) bool {
	keys := make([]K, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}

	sort.Slice(keys, func(i, j int) bool {
		return keys[i] < keys[j]
	})

	return func(f func(K, V) bool) bool {
		for _, key := range keys {
			value := m[key]
			if !f(key, value) {
				return false
			}
		}
		return true
	}
}

func parallelMapAttrs[K comparable, V1, V2 any](m map[K]V1, f func(K, V1) V2) map[K]V2 {
	dst := make(map[K]V2, len(m))
	var mu sync.Mutex

	pool := pool.New()
	for k, v := range m {
		k := k
		v := v

		pool.Go(func() {
			v2 := f(k, v)
			mu.Lock()
			dst[k] = v2
			mu.Unlock()
		})
	}

	pool.Wait()
	return dst
}

func mapAttrs[K comparable, V1, V2 any](m map[K]V1, f func(K, V1) V2) map[K]V2 {
	dst := make(map[K]V2, len(m))
	for k, v := range m {
		dst[k] = f(k, v)
	}
	return dst
}

func snakeToGo(s string) string {
	// TODO: vendor strcases.
	return strcases.SnakeToGo(true, s)
}

func pascalToGo(s string) string {
	return strcases.PascalToGo(s)
}

func resolveSchemas(proxies []*openapibase.SchemaProxy) ([]*openapibase.Schema, error) {
	schemas := make([]*openapibase.Schema, 0, len(proxies))
	var errs []error
	for _, proxy := range proxies {
		schema, err := proxy.BuildSchema()
		if err != nil {
			errs = append(errs, err)
			continue
		}
		schemas = append(schemas, schema)
	}
	return schemas, stderrors.Join(errs...)
}

func resolveNamedSchemas(proxies map[string]*openapibase.SchemaProxy) (map[string]*openapibase.Schema, error) {
	schemas := make(map[string]*openapibase.Schema, len(proxies))
	var errs []error
	for name, proxy := range proxies {
		schema, err := proxy.BuildSchema()
		if err != nil {
			errs = append(errs, err)
			continue
		}
		schemas[name] = schema
	}
	return schemas, stderrors.Join(errs...)
}
